'use strict';

const SymbolTree = require('..');
const test = require('tape');

function o() {
        // return an object that is unique in a deepEqual check

        return {
                unique : Symbol()
        };
}

test('test case internal prerequisite', function(t) {
        const a = o();
        t.notDeepEqual([o()], [o()]);
        t.deepEqual([a], [a]);
        t.end();
});

test('initialize', function(t) {
        const tree = new SymbolTree();
        const obj = {foo: 'bar'};

        t.equal(obj, tree.initialize(obj));
        t.deepEqual(['foo'], Object.getOwnPropertyNames(obj),
                'initialize() should not introduce any enumerable properties');

        t.end();
});

test('unassociated object', function(t) {
        const tree = new SymbolTree();
        const a = o();

        t.equal(false, tree.hasChildren    (a));
        t.equal(null , tree.firstChild     (a));
        t.equal(null , tree.lastChild      (a));
        t.equal(null , tree.previousSibling(a));
        t.equal(null , tree.nextSibling    (a));
        t.equal(null , tree.parent         (a));

        t.end();
});

test('insertBefore without parent or siblings', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const b = o();

        t.equal(a, tree.insertBefore(b, a));

        t.equal(false, tree.hasChildren(a));
        t.equal(null , tree.firstChild (a));
        t.equal(null , tree.lastChild  (a));
        t.equal(null , tree.parent     (a));
        t.equal(false, tree.hasChildren(b));
        t.equal(null , tree.firstChild (b));
        t.equal(null , tree.lastChild  (b));
        t.equal(null , tree.parent     (b));

        t.equal(null , tree.previousSibling(a));
        t.equal(b    , tree.nextSibling(a));
        t.equal(a    , tree.previousSibling(b));
        t.equal(null , tree.nextSibling(b));

        t.end();
});

test('insertAfter without parent or siblings', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const b = o();

        t.equal(b, tree.insertAfter(a, b));

        t.equal(false, tree.hasChildren (a));
        t.equal(null , tree.firstChild  (a));
        t.equal(null , tree.lastChild   (a));
        t.equal(null , tree.parent      (a));
        t.equal(false, tree.hasChildren (b));
        t.equal(null , tree.firstChild  (b));
        t.equal(null , tree.lastChild   (b));
        t.equal(null , tree.parent      (b));

        t.equal(null , tree.previousSibling(a));
        t.equal(b    , tree.nextSibling(a));
        t.equal(a    , tree.previousSibling(b));
        t.equal(null , tree.nextSibling(b));

        t.end();
});

test('prependChild without children', function(t) {
        const tree = new SymbolTree();
        const parent = o();
        const a = o();

        t.equal(a, tree.prependChild(parent, a));

        t.equal(false , tree.hasChildren    (a));
        t.equal(null  , tree.firstChild     (a));
        t.equal(null  , tree.lastChild      (a));
        t.equal(null  , tree.previousSibling(a));
        t.equal(null  , tree.nextSibling    (a));
        t.equal(parent, tree.parent         (a));

        t.equal(true , tree.hasChildren    (parent));
        t.equal(a    , tree.firstChild     (parent));
        t.equal(a    , tree.lastChild      (parent));
        t.equal(null , tree.previousSibling(a));
        t.equal(null , tree.nextSibling    (parent));
        t.equal(null , tree.parent         (parent));

        t.end();
});

test('appendChild without children', function(t) {
        const tree = new SymbolTree();
        const parent = o();
        const a = o();

        t.equal(a, tree.appendChild(parent, a));

        t.equal(false , tree.hasChildren    (a));
        t.equal(null  , tree.firstChild     (a));
        t.equal(null  , tree.lastChild      (a));
        t.equal(null  , tree.previousSibling(a));
        t.equal(null  , tree.nextSibling    (a));
        t.equal(parent, tree.parent         (a));

        t.equal(true , tree.hasChildren    (parent));
        t.equal(a    , tree.firstChild     (parent));
        t.equal(a    , tree.lastChild      (parent));
        t.equal(null , tree.previousSibling(a));
        t.equal(null , tree.nextSibling    (parent));
        t.equal(null , tree.parent         (parent));

        t.end();
});

test('prependChild with children', function(t) {
        const tree = new SymbolTree();
        const parent = o();
        const a = o();
        const b = o();

        tree.prependChild(parent, b);
        tree.prependChild(parent, a);

        t.equal(true , tree.hasChildren(parent));
        t.equal(a    , tree.firstChild (parent));
        t.equal(b    , tree.lastChild  (parent));

        t.equal(parent, tree.parent         (a));
        t.equal(null  , tree.previousSibling(a));
        t.equal(b     , tree.nextSibling    (a));

        t.equal(parent, tree.parent         (b));
        t.equal(a     , tree.previousSibling(b));
        t.equal(null  , tree.nextSibling    (b));
        t.end();
});

test('appendChild with children', function(t) {
        const tree = new SymbolTree();
        const parent = o();
        const a = o();
        const b = o();

        tree.appendChild(parent, a);
        tree.appendChild(parent, b);

        t.equal(true , tree.hasChildren(parent));
        t.equal(a    , tree.firstChild (parent));
        t.equal(b    , tree.lastChild  (parent));

        t.equal(parent, tree.parent         (a));
        t.equal(null  , tree.previousSibling(a));
        t.equal(b     , tree.nextSibling    (a));

        t.equal(parent, tree.parent         (b));
        t.equal(a     , tree.previousSibling(b));
        t.equal(null  , tree.nextSibling    (b));
        t.end();
});

test('insertBefore with parent', function(t) {
        const tree = new SymbolTree();
        const parent = o();
        const a = o();
        const b = o();

        tree.prependChild(parent, b);
        tree.insertBefore(b, a);

        t.equal(true , tree.hasChildren(parent));
        t.equal(a    , tree.firstChild (parent));
        t.equal(b    , tree.lastChild  (parent));

        t.equal(parent, tree.parent         (a));
        t.equal(null  , tree.previousSibling(a));
        t.equal(b     , tree.nextSibling    (a));

        t.equal(parent, tree.parent         (b));
        t.equal(a     , tree.previousSibling(b));
        t.equal(null  , tree.nextSibling    (b));
        t.end();
});

test('insertAfter with parent', function(t) {
        const tree = new SymbolTree();
        const parent = o();
        const a = o();
        const b = o();

        tree.appendChild(parent, a);
        tree.insertAfter(a, b);

        t.equal(true , tree.hasChildren(parent));
        t.equal(a    , tree.firstChild (parent));
        t.equal(b    , tree.lastChild  (parent));

        t.equal(parent, tree.parent         (a));
        t.equal(null  , tree.previousSibling(a));
        t.equal(b     , tree.nextSibling    (a));

        t.equal(parent, tree.parent         (b));
        t.equal(a     , tree.previousSibling(b));
        t.equal(null  , tree.nextSibling    (b));
        t.end();
});

test('insertBefore with siblings', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const b = o();
        const c = o();

        tree.insertBefore(c, a);
        tree.insertBefore(c, b);

        t.equal(null, tree.previousSibling(a));
        t.equal(b   , tree.nextSibling(a));

        t.equal(a   , tree.previousSibling(b));
        t.equal(c   , tree.nextSibling(b));

        t.equal(b   , tree.previousSibling(c));
        t.equal(null, tree.nextSibling(c));

        t.end();
});

test('insertAfter with siblings', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const b = o();
        const c = o();

        tree.insertAfter(a, c);
        tree.insertAfter(a, b);

        t.equal(null, tree.previousSibling(a));
        t.equal(b   , tree.nextSibling(a));

        t.equal(a   , tree.previousSibling(b));
        t.equal(c   , tree.nextSibling(b));

        t.equal(b   , tree.previousSibling(c));
        t.equal(null, tree.nextSibling(c));

        t.end();
});

test('remove with previous sibling', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const b = o();

        tree.insertAfter(a, b);
        tree.remove(b);

        t.equal(null, tree.previousSibling(a));
        t.equal(null, tree.nextSibling    (a));
        t.equal(null, tree.parent         (a));

        t.equal(null, tree.previousSibling(b));
        t.equal(null, tree.nextSibling    (b));
        t.equal(null, tree.parent         (b));

        t.end();
});

test('remove with next sibling', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const b = o();

        tree.insertAfter(a, b);
        tree.remove(a);

        t.equal(null, tree.previousSibling(a));
        t.equal(null, tree.nextSibling    (a));
        t.equal(null, tree.parent (a));

        t.equal(null, tree.previousSibling(b));
        t.equal(null, tree.nextSibling    (b));
        t.equal(null, tree.parent (b));

        t.end();
});

test('remove with siblings', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const b = o();
        const c = o();

        tree.insertAfter(a, b);
        tree.insertAfter(b, c);
        tree.remove(b);

        t.equal(null, tree.previousSibling   (a));
        t.equal(c   , tree.nextSibling   (a));
        t.equal(null, tree.parent (a));

        t.equal(null, tree.previousSibling   (b));
        t.equal(null, tree.nextSibling   (b));
        t.equal(null, tree.parent (b));

        t.equal(a   , tree.previousSibling   (c));
        t.equal(null, tree.nextSibling   (c));
        t.equal(null, tree.parent (c));

        t.end();
});

test('remove with parent', function(t) {
        const tree = new SymbolTree();
        const parent = o();
        const a = o();

        tree.prependChild(parent, a);
        tree.remove(a);

        t.equal(null, tree.parent(a));
        t.equal(null, tree.firstChild(parent));
        t.equal(null, tree.lastChild (parent));

        t.end();
});

test('remove with children', function(t) {
        const tree = new SymbolTree();
        const parent = o();
        const a = o();

        tree.prependChild(parent, a);
        tree.remove(parent);

        t.equal(parent, tree.parent(a));
        t.equal(a, tree.firstChild(parent));
        t.equal(a, tree.lastChild (parent));

        t.end();
});

test('remove with parent and siblings', function(t) {
        const tree = new SymbolTree();
        const parent = o();
        const a = o();
        const b = o();
        const c = o();

        tree.prependChild(parent, a);
        tree.insertAfter(a, b);
        tree.insertAfter(b, c);
        tree.remove(b);

        t.equal(a, tree.firstChild(parent));
        t.equal(c, tree.lastChild (parent));

        t.equal(null  , tree.previousSibling   (a));
        t.equal(c     , tree.nextSibling   (a));
        t.equal(parent, tree.parent (a));

        t.equal(null  , tree.previousSibling   (b));
        t.equal(null  , tree.nextSibling   (b));
        t.equal(null  , tree.parent (b));

        t.equal(a     , tree.previousSibling   (c));
        t.equal(null  , tree.nextSibling   (c));
        t.equal(parent, tree.parent (c));

        t.end();
});

test('inserting an already associated object should fail', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const b = o();

        tree.insertBefore(b, a);

        // jscs:disable requireBlocksOnNewline

        // `nextSibling` check
        t.throws(function() { tree.insertBefore(b, a); }, /already present/);
        t.throws(function() { tree.insertAfter (b, a); }, /already present/);
        t.throws(function() { tree.prependChild (b, a); }, /already present/);
        t.throws(function() { tree.appendChild  (b, a); }, /already present/);

        // `previousSibling` check
        t.throws(function() { tree.insertBefore(a, b); }, /already present/);
        t.throws(function() { tree.insertAfter (a, b); }, /already present/);
        t.throws(function() { tree.prependChild (a, b); }, /already present/);
        t.throws(function() { tree.appendChild  (a, b); }, /already present/);

        tree.remove(a);

        tree.prependChild(b, a);
        // `parent` check
        t.throws(function() { tree.insertBefore(b, a); }, /already present/);
        t.throws(function() { tree.insertAfter (b, a); }, /already present/);
        t.throws(function() { tree.prependChild (b, a); }, /already present/);
        t.throws(function() { tree.appendChild  (b, a); }, /already present/);

        // jscs:enable requireBlocksOnNewline

        t.end();
});

test('Multiple SymbolTree instances should not conflict', function(t) {
        const tree1 = new SymbolTree();
        const tree2 = new SymbolTree();
        const a = o();
        const b = o();

        tree1.insertBefore(b, a);
        tree2.insertBefore(a, b);

        t.equal(null, tree1.previousSibling(a));
        t.equal(b   , tree1.nextSibling(a));
        t.equal(a   , tree1.previousSibling(b));
        t.equal(null, tree1.nextSibling(b));

        t.equal(null, tree2.previousSibling(b));
        t.equal(a   , tree2.nextSibling(b));
        t.equal(b   , tree2.previousSibling(a));
        t.equal(null, tree2.nextSibling(a));

        t.end();
});

test('lastInclusiveDescendant', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const aa = o();
        const ab = o();
        const aba = o();
        const abaa = o();
        const b = o();

        tree.appendChild(a, aa);
        tree.appendChild(a, ab);
        tree.appendChild(ab, aba);
        tree.appendChild(aba, abaa);
        tree.insertAfter(a, b);

        t.equal(abaa, tree.lastInclusiveDescendant(a));

        t.end();
});

test('look up preceding with a previous sibling', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const b = o();

        tree.insertAfter(a, b);

        t.equal(null, tree.preceding(a));
        t.equal(a, tree.preceding(b));

        t.end();
});

test('look up preceding with a previous sibling with a child', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const aa = o();
        const ab = o();
        const b = o();

        tree.appendChild(a, aa);
        tree.appendChild(a, ab);
        tree.insertAfter(a, b);

        t.equal(null, tree.preceding(a));
        t.equal(a   , tree.preceding(aa));
        t.equal(aa  , tree.preceding(ab));
        t.equal(ab  , tree.preceding(b));

        t.end();
});

test('look up preceding with a previous sibling with a descendants', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const aa = o();
        const ab = o();
        const aba = o();
        const abaa = o();
        const b = o();

        tree.appendChild(a, aa);
        tree.appendChild(a, ab);
        tree.appendChild(ab, aba);
        tree.appendChild(aba, abaa);
        tree.insertAfter(a, b);

        t.equal(abaa, tree.preceding(b));

        t.end();
});

test('look up preceding using a specified root', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const aa = o();

        tree.appendChild(a, aa);

        t.equal(null, tree.preceding(a , {root: a}));
        t.equal(a   , tree.preceding(aa, {root: a}));
        t.equal(null, tree.preceding(aa, {root: aa}));

        t.end();
});

test('following with a child', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const aa = o();

        tree.appendChild(a, aa);

        t.equal(aa  , tree.following(a));
        t.equal(null, tree.following(aa));

        t.end();
});

test('following with a nextSibling sibling', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const b = o();

        tree.insertAfter(a, b);

        t.equal(b   , tree.following(a));
        t.equal(null, tree.following(b));

        t.end();
});

test('following with sibling of parent', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const aa = o();
        const b = o();

        tree.appendChild(a, aa);
        tree.insertAfter(a, b);

        t.equal(b, tree.following(aa));

        t.end();
});

test('following with sibling of grandparent', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const aa = o();
        const aaa = o();
        const b = o();

        tree.appendChild(a, aa);
        tree.appendChild(aa, aaa);
        tree.insertAfter(a, b);

        t.equal(b, tree.following(aaa));

        t.end();
});

test('following using a specified root', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const aa = o();
        const aaa = o();
        const b = o();

        tree.appendChild(a, aa);
        tree.appendChild(aa, aaa);
        tree.insertAfter(a, b);

        t.equal(null, tree.following(aaa, {root: aaa}));
        t.equal(null, tree.following(aaa, {root: aa}));
        t.equal(null, tree.following(aaa, {root: a}));
        t.equal(aa  , tree.following(a  , {root: a}));
        t.equal(aaa , tree.following(aa , {root: a}));

        t.end();
});

test('following with skipChildren', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const aa = o();
        const b = o();

        tree.appendChild(a, aa);
        tree.insertAfter(a, b);

        t.equal(b, tree.following(a, {skipChildren: true}));

        t.end();
});

test('childrenToArray', function(t) {
        const tree = new SymbolTree();
        const a = o();
        const 